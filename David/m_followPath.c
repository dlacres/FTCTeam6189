#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Motor,  mtr_Matrix_S1_1, ltWheelMotor,  tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S1_2, rtWheelMotor,  tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, motorF,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_4, motorG,        tmotorMatrix, openLoop)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, servo3,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//
// David Lempia 12/8/13 - Change the distance count to a long from int. The count was overflowing.
//
#include "i_debug.c"
#include "i_limit.c"
#include "i_rateLimit.c"
#include "i_direction.c"
#include "i_forwardDist.c"
//--------------------Path definition----------------------//
#define SPD 40;
#define DIST_IDX 0
#define DIR_IDX 1
#define SPD_IDX 2
#define DIRRL_IDX 3
int pathIdx=0;
// Dist, Dir, FwdSpd, TurnSpd
int path[][]={
		{48, 0, 50, 100},
		{48, 90, 50, 100},
		{48, 0, 50, 100}};
//*--------------------Foreground---------------------------//
// Story: As an explorer, I want to upload a path so the robot can drive to a new location.
// [] Follow path stored in an array
// [] Stop at the end of the path
#define FOREGROUND_MS 50
task Foreground(){
  int timeLeft;
	while(true){
		ClearTimer(T1);
		hogCPU();
		//--------------------Robot Code---------------------------//

		long robotDist = nMotorEncoder[rtWheelMotor] + nMotorEncoder[ltWheelMotor];
		int robotDir  = (int)(nMotorEncoder[ltWheelMotor] - nMotorEncoder[rtWheelMotor]);

		// Calculate the speed and direction commands
    int speedCmd = ForwardDist(path[pathIdx][DIST_IDX], robotDist, path[pathIdx][SPD_IDX]);
		int dirCmd=Direction(path[pathIdx][DIR_IDX], robotDir, path[pathIdx][DIRRL_IDX]);

		DebugInt("spd",speedCmd);
		DebugInt("dir",dirCmd);

		// Calculate when to move to the next path index
		if (abs(speedCmd)<2 && abs(dirCmd)<2) pathIdx++;

		// Protect the path index. It should never get to large.
		int s=sizeof(path)/sizeof(path[0])-1;
		DebugInt("siz",s);
		if (pathIdx>s) pathIdx=s;

		// Calculate the motor commands given the speed and direction commands.
		motor[ltWheelMotor]=speedCmd+dirCmd;
		motor[rtWheelMotor]=speedCmd-dirCmd;

		//--------------------------Robot Code--------------------------//
		// Wait for next itteration
	  timeLeft=FOREGROUND_MS-time1[T1];
	  releaseCPU();
	  wait1Msec(timeLeft);
	}// While
}//Foreground
task main()
{
	//--------------------INIT Code---------------------------//
  ForwardDistReset((tMotor)rtWheelMotor, (tMotor)ltWheelMotor);
	DirectionReset();
	//--------------------End INIT Code--------------------------//

  StartTask(Foreground, 255);

  while(true){

  	//-----------------Print the debug statements out------------------//
		DebugPrint();

	}// While
}// Main
