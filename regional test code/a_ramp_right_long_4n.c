#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S3, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  motorA,          leftsweeper,   tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          light,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          rightsweeper,  tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     ltMotor,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rtMotor,       tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     ltBack,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     rtBack,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     flagraiser,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     blockthrower,  tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     robotlifter,   tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     blockgrabber,  tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S3_C1_1,    irArm,                tServoStandard)
#pragma config(Servo,  srvo_S3_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//
// As a game strategest, I want the robot to drive forward up the ramp and place the block in the IR beacon
//
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "i_PID3.c"
#include "i_delayatrue.c"
#include "i_debug.c"
#include "i_limit.c"
#include "i_rateLimit.c"
#include "i_direction.c"
#include "i_forwardDist.c"
#include "i_flipperArm_auto.c"//1510 lines of code
//-------------------Path definition----------------------//
// dist, dir, spd
int path[][]={
		{30, 0, 75},
		{38, -45, 100},
		{73, -45, 75},
		{73, -45, 75}
								};
int path2[][]={
		{30, 0, 75},
		{38, -45, 100},
		{63, -45, 75},
		{73, -45, 75},
		{73, -45, 75}
							};
int armSetPos = 0;
#define SPD 40;
#define DIST_IDX 0
#define DIR_IDX 1
#define SPD_IDX 2
#define servoIn 243
#define servoOut 115
int pathIdx=0,path2Idx=0;
int speedCmdZ1=0;
int rightmotors;
int leftmotors;
void initializeRobot()
{
servo[irArm]=243;
}
//*--------------------Foreground---------------------------//
// Story: As a player, I want the robot to follow a path so i can score autonomous points in a game
// [x] Follow path stored in an array
// [x] Stop at the end of the path
//#define FOREGROUND_MS 50
//task Foreground(){
// ------------------------Main Task -----------------------------//
// Run 20 times every second
#define FOREGROUND_MS 50
task main(){

	//--------------------INIT Code---------------------------//
  ForwardDistReset((tMotor)rtMotor, (tMotor)ltMotor);
	DirectionReset();
	nMotorEncoder[blockthrower] = 0;
	speedCmdZ1=0;
	pathIdx=0;path2Idx=0;
	delayatruecount=0;
	int state=0;
	Pid_Init1();
	Pid_Init2();
	servo[irArm]=servoIn;
	long ltMtrEncoderOld=0, rtMtrEncoderOld=0;
	long ltMtrEncoder,rtMtrEncoder;
	//--------------------End INIT Code--------------------------//
initializeRobot();
  waitForStart(); // Wait for the beginning of autonomous phase.

	int iFrameCnt=0;
	int timeLeft;
	while(true){
		ClearTimer(T1);
		hogCPU();
		long  robotDist;
		long  robotDir;
		//--------------------Robot Code---------------------------//
		long armEncoder = nMotorEncoder[blockthrower];
		rtMtrEncoder=nMotorEncoder[rtMotor];
		ltMtrEncoder=nMotorEncoder[ltMotor];

		if (abs(ltMtrEncoderOld-ltMtrEncoder)>1000 || abs(rtMtrEncoderOld-rtMtrEncoder)>1000){
			robotDist = rtMtrEncoderOld + ltMtrEncoderOld;
			robotDir  = ltMtrEncoderOld - rtMtrEncoderOld;
		} else {
			robotDist = rtMtrEncoder + ltMtrEncoder;
			robotDir  = ltMtrEncoder - rtMtrEncoder;
			ltMtrEncoderOld=ltMtrEncoder;
			rtMtrEncoderOld=rtMtrEncoder;
		}
		long  distInches = robotDist/IN2CLK;
		long  dirDegrees = robotDir/DEG2CLK;

		// Calculate the speed and direction commands
    int speedCmd = ForwardDist(path[pathIdx][DIST_IDX], robotDist, path[pathIdx][SPD_IDX]);
		int dirCmd   = Direction(path[pathIdx][DIR_IDX], robotDir);
		int armSpd   = FlipperArm(armEncoder, armSetPos);
		bool IRval;

		//calculate when to increment path
		if (abs(path[pathIdx][DIR_IDX] - dirDegrees) < 4 && abs(path[pathIdx][DIST_IDX] - distInches) < 3) pathIdx++;

		// Calculate the IR value
		IRval = Delayatrue(1, SensorValue[IR] == 3 || SensorValue[IR] == 4);

		if (state==0)// State O Follow Path
		{
			if (abs(dirDegrees)>44)
			{
				state=2;
				servo[irArm]=servoOut;
			}
		}
/*		if(state==1)// State 1 Swing out irArm
		{
			servo[irArm]=servoOut;
			if (distInches>36)
			{
				state=2;
			}
		}*/
		if (state==2)// state 2 look for ir under box 1
		{
//		  speedCmd=10;
		  // speedCmd=0;

		  if ( IRval)
		  {
				state=12;
		  	servo[irArm]=servoIn;
		  }
		  else
		  {
		  	state=3;
		  }
		}
		if (state==12)//follows path before flipping arm
		{
			if(distInches>38)
			{
				state = 8;
			}
		}
		if (state==3)//state 3 look for box 2 and follow path
		{

			if (distInches>44)
			{
				state=4;
			}
		}
		if (state==4)//state 4 look for ir under box 2
		{
//		  speedCmd=10;
		  if ( IRval==true)
		  {
		  	state=13;
		  }
		  else
		  {
		  	state=15;
		  }
		  servo[irArm]=servoIn;
		}
		if (state==13) // waits for distance before flipping
		{
			if(distInches>56)
			{
				state = 8;
			}
		}
		if (state==15) // pulls servo arm in
		{
			//speedCmd=0;
			if(distInches>59)
			{
				servo[irArm] = servoOut;
				state =5;
			}
		}
		if (state==5)//state 5 look for box 3 and follow path
		{
			if (distInches>61)//36
			{
				state=6;
			}
		}
		 if (state==6)// State 6 Look for ir under box 3
		 {
//		   speedCmd=10;
		  if ( IRval==true)
		  {
		  	state=14;
		  	path2Idx=pathIdx;
		  }
		  else
		  {
		  	state=7;
		  }
	    servo[irArm]=servoIn;
		}
		if (state==14)// waits distance before flipping arm
		{
			if (abs(path2[path2Idx][DIR_IDX] - dirDegrees) < 4 && abs(path2[path2Idx][DIST_IDX] - distInches) < 3) path2Idx++;
	    speedCmd = ForwardDist(path2[path2Idx][DIST_IDX], robotDist, path2[path2Idx][SPD_IDX]);
			dirCmd   = Direction(path2[path2Idx][DIR_IDX], robotDir);
			if(path2Idx == 3)
				state = 8;
		}
		if (state==7)// State 7 look for box 4
		{
			if (pathIdx == 3)//45
			{
				state=8;
			}
		}
		if (state==8)// state 8 flip arm
		{
			servo[irArm]=servoIn;
			speedCmd=0;
			dirCmd = 0;
			armSetPos = 2300;
			if (abs(armSetPos - armEncoder) <10)
			{
				state=9;
			}
		}
		if (state==9)//state 9 lower arm
		{
			speedCmd = 0;
			dirCmd = 0;
			armSetPos = 0;
			if (abs(armSetPos - armEncoder) < 400)
			{
				pathIdx=3;
				state=10;
			}
		}
		if(state==10)//state 10 follow path
		{
		}

		//DebugInt("spd",speedCmd);
		//DebugInt("dir",robotDir/DEG2CLK);
		//DebugInt("dist",distInches);
		//DebugInt("path",pathIdx);
    //DebugInt("state",state);
    //DebugInt("irval",SensorValue[IR]);

		// Calculate when to move to the next path index
		int s=sizeof(path)/sizeof(path[0])-1;
		if (pathIdx>s) pathIdx=s; // Protect the path index
		int s2=sizeof(path2)/sizeof(path2[0])-1;
		if (path2Idx>s2) path2Idx=s2; // Protect the path index

		// Ramp the command up
		speedCmd = RateLimit(speedCmd, START_RATE,speedCmdZ1);
		leftmotors=speedCmd+dirCmd;
		rightmotors=speedCmd-dirCmd;
		//rightmotors=speedCmd-dirCmd;
		//leftmotors=speedCmd+dirCmd;
		motor[rtBack]=rightmotors;
		motor[rtMotor]=rightmotors;
		motor[ltMotor]=leftmotors;
		motor[ltBack]=leftmotors;
		motor[blockthrower]=armSpd;
		//DebugInt("rightmotors",rightmotors);
		//DebugInt("leftmotors",leftmotors);
		//DebugInt("rightencoder",nMotorEncoder[rtMotor]);
		//DebugInt("leftencoder",nMotorEncoder[ltMotor]);
		if (iFrameCnt==0)
			writeDebugStreamLine("i,pthIdx,rbtDist,ir,spdCmd,state");
		writeDebugStreamLine("%3i,%3i,%4i,%4i,%3i,%3i",iFrameCnt,pathIdx,distInches,SensorValue[IR],speedCmd,state);
		//--------------------------Robot Code--------------------------//
		// Wait for next itteration
		iFrameCnt++;
	  timeLeft=FOREGROUND_MS-time1[T1];
	  releaseCPU();
	  wait1Msec(timeLeft);
	}// While
}//Foreground
