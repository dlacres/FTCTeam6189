#pragma config(Sensor, S1,     endPgm,         sensorTouch)
#pragma config(Motor,  motorA,          rtMotor,       tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "i_Lowpass.c"

#define Kp 3  // Kp
#define Ki 2 // Ki
#define Kd (-1)   //Kd

int error=0;
int integral=0;
int acceleration=0;
int distanceOld=0;
int speed,speedOld=0;
int output=0;

#define MAX_INTEGRAL 30

void Pid_Init(){
	distanceOld=0;
	speedOld=0;
	integral=0;
  nMotorEncoder[rtMotor]=0;  // initialize encoder of motor B
  nMotorPIDSpeedCtrl[rtMotor] = mtrNoReg;//disable NXT inbuilt PID
	nSyncedMotors = synchNone;//disable NXT inbuilt PID
	return;
}
bool failedPid=false;
int Pid(int speedCmd, int distance){
	int integralKi,errorKp;

	//AddToDatalog(0,distance);
//	distance = nMotorEncoder[motorB];  // find actual degrees of motor B
	speed = distance - distanceOld; distanceOld=distance;
	acceleration = speed - speedOld; speedOld=speed;
  error=speedCmd/Kp-speed;  // Normilize speedCmd to the size of motor command 0->100.
  errorKp=error*Kp;
  integral=integral+error;  // find value of integral
  integralKi=integral*Ki;   // Normilize to the size of motor command 0->100.
  if (integralKi>MAX_INTEGRAL) integralKi=MAX_INTEGRAL; // Limit the value of the integral
  if (integralKi<-MAX_INTEGRAL) integralKi=-MAX_INTEGRAL;

  output=errorKp+integralKi+Kd*acceleration;

  if (Lowpass(errorKp,0.2)>20 || failedPid){
  	failedPid=true;
  	output=0;
  }

  //AddToDatalog(1, actualDegreesC);

	return((int)output);
}

// Periodic Model used to read sensors and control the motors on a NXT brick
//
// As a software programmer, I want my tasks to run at a periodic rate. A periodic rate makes control, filtering,
//    and counting much easier.
//
#pragma DebuggerWindows ("debugStream")// Bring up the debug stream window

int count=0;
int timeLeft=0; // A global variable that sticks around each frame

// ------------------------Foreground Task -----------------------------//
// Run every second
#define FOREGROUND_MS 50 //I change this to 50 when I control the robot. 1000 is good for testing.
task main(){
	int spdCmd;
  //---------------------------INIT-----------------------------------//
	Pid_Init();

  //---------------------------END INIT-------------------------------//
//	while(SensorValue(endPgm) == 0){
	while(true){
		ClearTimer(T1);
		hogCPU(); //Prevent other tasks from running when this one is.
		//writeDebugStreamLine("Foreground\n"); //Let me know when the foreground runs
	  count=count+1; // Count the number of times the foreground runs.

	  //--------------------------FOREGROUND------------------------------------//
	  spdCmd=50;
		motor[rtMotor]=Pid(spdCmd, nMotorEncoder[rtMotor]);

	  //--------------------------END FOREGROUND--------------------------------//

	  timeLeft=FOREGROUND_MS-time1[T1]; // Calculate the time used in the foreground
	  releaseCPU(); // Let other tasks run now.
	  wait1Msec(timeLeft);// The time other tasks have to run before foreground takes control.
	 	if (count==1){
	  	writeDebugStreamLine("SpdCmd[%i],Kp[%i],Ki[%i],Kd[%i]",spdCmd,Kp,Ki,Kd);
	  	writeDebugStreamLine("Count,Error,MtrCmd,Speed,Integral,Distance");
	  }
	 	writeDebugStreamLine("%2i,%3i,%3i,%3i,%3i,%5i",count,error,motor[rtMotor],speed,integral,nMotorEncoder[rtMotor]);

	}// While Loop
}// Foreground Main Task
