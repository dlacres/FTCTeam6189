/*#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_Matrix_S1_1, ltWheelMotor,  tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_2, rtWheelMotor,  tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, motorF,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_4, motorG,        tmotorMatrix, openLoop)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, servo3,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*/

/*====================Add / for debug======================//
#include "i_debug.c"
#include "i_rateLimit.c"
#include "i_limit.c"
//*/
// Story: As a software designer I want to control the direction the robot goes.
// Assume that the left motor is called motorLt and the right motor is
// Dependency: i_rateLimit.c, i_limit.c
// Usage: A positive dirCmd is turn right. Returns the direction command.
// Tuning:
#define DEG2CLK 35
#define DIR_KP 25 // Start tuning by setting this to around 25. Bigger numbers are a smaller gain
//#define DIR_RL 100
//------------------Direction Controller-----------------------//
//int robotDirInt=(int)(nMotorEncoder[ltWheelMotor] - nMotorEncoder[rtWheelMotor]);
//dirCmdInt=Direction(dirCmdInt, robotDirInt, 100);
int directionRl=0;
int Direction(int dirCmd, int dir, int dir_rl)
{
	int dirMotorCmd;

	dirCmd=RateLimit(dirCmd*DEG2CLK,dir_rl,directionRl);
	DebugInt("dCmd",dirCmd);
	dirMotorCmd = (dirCmd-dir)/DIR_KP;
	DebugInt("dmCmd",dirMotorCmd);

	return(dirMotorCmd);
}
//------------------Direction Reset-----------------------//
void DirectionReset(){
	directionRl=0;
}
/*====================Add / for debug======================//
// Add this code to a while loop in main
// Unit Test
// [] drive forward to specific inch distance
// [] drive backward to a specific inch distance

#define FOREGROUND_MS 50
task Foreground(){
  int timeLeft;
//	int iFrameCnt=0;
//	int out,in=0;

	while(true){
		ClearTimer(T1);
		hogCPU();
		//--------------------UNIT TEST Code---------------------------//

		int rDirCmd=90; // Degrees

  	DebugInt("rDir",rDirCmd);

		int robotDir=nMotorEncoder[ltWheelMotor] - nMotorEncoder[rtWheelMotor];
  	DebugInt("rDir",robotDir);
		int dirCmd=Direction(rDirCmd, robotDir, 100);
  	DebugInt("dCmd2",dirCmd);

		motor[ltWheelMotor]=dirCmd;
		motor[rtWheelMotor]=-dirCmd;

		//--------------------------End UNIT TEST Code--------------------------//
		// Wait for next itteration
	  timeLeft=FOREGROUND_MS-time1[T1];
	  releaseCPU();
	  wait1Msec(timeLeft);
	}// While
}//Foreground
task main()
{
	int iFrameCnt=0;
	//--------------------UNIT TEST INIT Code---------------------------//

		nMotorEncoder[ltWheelMotor]=0;
		nMotorEncoder[rtWheelMotor]=0;

	//--------------------------End UNIT TEST INIT Code--------------------------//

  StartTask(Foreground, 255);

  while(true){

  	//-----------------Print the debug statements out------------------//
		DebugPrint();

	}// While
}// Main
//*/
