#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Motor,  mtr_Matrix_S1_1, ltWheelMotor,  tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S1_2, rtWheelMotor,  tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, motorF,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_4, motorG,        tmotorMatrix, openLoop)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, servo3,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//
// David Lempia 12/8/13 - Change the distance count to a long from int. The count was overflowing.
//
#include "i_debug.c"
#include "i_limit.c"
#include "i_rateLimit.c"
#include "i_direction.c"
#include "i_forwardDist.c"
//--------------------Path definition----------------------//
#define SPD 40;
#define DIST_IDX 0
#define DIR_IDX 1
#define SPD_IDX 2
#define DIRRL_IDX 3
//*--------------------Foreground---------------------------//
// Story: As a FTC Strategest, I want the robot to drive straight and make smooth turns without stopping
//    so that the robot can quickly get up the ramp.
// Story2: As a FTC mechanical team, I want the robot to decrease the motor command to 0 if the motor
//    stalls so that the motor will not burn up.
// [] Use SM to drive straight then stop.
// [] Use SM to drive straight, turn 90 degrees, then stop.
// [] Set the motor command to 0 if it begins to stall.
//
#define FOREGROUND_MS 50
task Foreground(){
  int timeLeft;
	while(true){
		ClearTimer(T1);
		hogCPU();
		//--------------------Robot Code---------------------------//

		long robotDist = nMotorEncoder[rtWheelMotor] + nMotorEncoder[ltWheelMotor];
		int robotDir  = (int)(nMotorEncoder[ltWheelMotor] - nMotorEncoder[rtWheelMotor]);

		// Calculate the speed and direction commands
//    int speedCmd = ForwardDist(path[pathIdx][DIST_IDX], robotDist, path[pathIdx][SPD_IDX]);
//		int dirCmd=Direction(path[pathIdx][DIR_IDX], robotDir, path[pathIdx][DIRRL_IDX]);

//		DebugInt("spd",speedCmd);
//		DebugInt("dir",dirCmd);

		#define FWDa 1
		#define	RT90a 2
		int sm=FWD1;
		int speedCmd=0;
		int dirCmd=0;

		switch sm {
		case FWDa: //Drive Forward
    	speedCmd = ForwardDist(10, robotDist, 50);// CmdStopDist,,CmdSpeed
			dirCmd=Direction(0, robotDir, 50);// CmdDir,,RateLimitValue
			break;
		default:
		}
		// Calculate the motor commands given the speed and direction commands.
//		motor[ltWheelMotor]=speedCmd+dirCmd;
//		motor[rtWheelMotor]=speedCmd-dirCmd;

		//--------------------------Robot Code--------------------------//
		// Wait for next itteration
	  timeLeft=FOREGROUND_MS-time1[T1];
	  releaseCPU();
	  wait1Msec(timeLeft);
	}// While
}//Foreground
task main()
{
	//--------------------INIT Code---------------------------//
  ForwardDistReset((tMotor)rtWheelMotor, (tMotor)ltWheelMotor);
	DirectionReset();
	//--------------------End INIT Code--------------------------//

  StartTask(Foreground, 255);

  while(true){

  	//-----------------Print the debug statements out------------------//
		DebugPrint();

	}// While
}// Main
