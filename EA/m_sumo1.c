#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S2,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  motorA,          ltMotor,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          rtMotor,       tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "DriveDistance.c"

#define FORWARD 0
#define BACKUP 1
#define TURN 2
#define STOP 3
#define RAM 4
short currentState=FORWARD;
short nextState;
short lightIntensity;
int turnClicks;
int iFrameCnt=0;
int Sonar=35;
int Sonar1=35;

int RandomNumberBetween(int min, int max){
	return((rand() % (max-min)) + min);
}
void ResetLight(){
	lightIntensity=SensorValue(lightSensor);
	wait1Msec(10);
	lightIntensity=(SensorValue(lightSensor)+lightIntensity);
	wait1Msec(10);
	lightIntensity=(SensorValue(lightSensor)+lightIntensity)/3;
}
bool SeeEdge(){
	if (abs(lightIntensity-SensorValue(lightSensor))>15)
		return(true);
	return(false);
}
bool SeeRobot(){
	int dist;

	Sonar=SensorValue[sonarSensor];
	if (Sonar1>Sonar) dist=Sonar1; // MAX - Make sure the sonar is short for 2 readings in a row (noise)
	else dist=Sonar;
	Sonar1=Sonar;

	if (dist<30)
		return(true);
	return(false);
}
long RobotDistanceClicks(){
		return(nMotorEncoder[ltMotor]+nMotorEncoder[rtMotor]);
}
bool isRobotDistanceClicks(long dist){
	return(abs(nMotorEncoder[ltMotor]+nMotorEncoder[rtMotor])>abs(dist));
}
long RobotDirectionClicks(){
	return(nMotorEncoder[ltMotor]-nMotorEncoder[rtMotor]);
}
bool isRobotDirectionClicks(int dir){
	return(abs(nMotorEncoder[ltMotor]-nMotorEncoder[rtMotor])>abs(dir));
}
void ResetRobotClicks(){
	nMotorEncoder[ltMotor]=0;
	nMotorEncoder[rtMotor]=0;
}
void Stop(){
	motor[ltMotor]=0;
	motor[rtMotor]=0;
}
void ForwardCmd(int cmd){
	motor[ltMotor]=cmd;
	motor[rtMotor]=cmd;
}
void TurnCmd(int cmd){
	motor[ltMotor]=cmd;
	motor[rtMotor]=-cmd;
}
#define FOREGROUND_MS 50
task main(){
  int timeLeft;

//	int iFrameCnt=0;
//	int out,in=0;
	//--------------------UNIT TEST INIT Code---------------------------//

		ResetRobotClicks();
		ResetLight();

	//--------------------------End UNIT TEST INIT Code--------------------------//

	while(true){
		ClearTimer(T1);
		hogCPU();
		//--------------------UNIT TEST Code---------------------------//

//#include "i_SumoSM.c"

		switch (currentState) {
		case FORWARD:
			ForwardCmd(50);
			if (SeeRobot()){
				nextState=RAM;
				ResetRobotClicks();
			}
			if (SeeEdge()){
				nextState=BACKUP;
				ResetRobotClicks();
			}
			break;
		case RAM:
			ForwardCmd(100);
			if (SeeEdge()){
				ResetRobotClicks();
				nextState=BACKUP;
			}
			if (!SeeRobot()){
				nextState=FORWARD;
				ResetRobotClicks();
			}
			if (isRobotDistanceClicks(300)){
				ResetRobotClicks();
				nextState=FORWARD;
			}
			break;
		case BACKUP:
			ForwardCmd(-50);
			if (isRobotDistanceClicks(100)){
				nextState=TURN;
				//turnClicks=400;
				turnClicks=RandomNumberBetween(650,1050);
				ResetRobotClicks();
			}
			break;
		case TURN:
			TurnCmd(25);
			if (SeeRobot()){
				nextState=RAM;
				ResetRobotClicks();
			}
			if (isRobotDirectionClicks(turnClicks)){
				nextState=FORWARD;
				ResetRobotClicks();
			}
			break;
		case STOP:
		default:
			Stop();
			break;
		}
		currentState=nextState;
//		ForwardCmd(25);
//		if (isRobotDistanceClicks(1000))
//			Stop();
		//--------------------------End UNIT TEST Code--------------------------//

		// Printout Debug Statements
		#pragma DebuggerWindows ("debugStream")// Bring up the debug stream window
/*		if (iFrameCnt==0)
			writeDebugStreamLine("%5s","curState");
		writeDebugStreamLine("%5i",currentState);*/

		// Wait for next itteration
		++iFrameCnt;
	  timeLeft=FOREGROUND_MS-time1[T1];
	  if (timeLeft<0) timeLeft=0;
	  releaseCPU();
	  wait1Msec(timeLeft);
	}// While
}//main
