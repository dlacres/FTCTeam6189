#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_Matrix_S1_1, ltWheelMotor,  tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_2, rtWheelMotor,  tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, motorF,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_4, motorG,        tmotorMatrix, openLoop)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, servo3,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*/

#pragma debuggerWindows("joystickSimple");

//*/
// Story: As an explorer, I want to follow a path, return on the path, drive the joystick, or drive the tophat.
// Story: As a software designer I want to smoothly change the direction the robot goes as it follows a path.
// Dependency: i_rateLimit.c, i_limit.c
// Usage: A positive dirCmd is turn right. Returns the direction command.
// Tuning:

long mrtLtClk, mrtLtClkOld=0, mtrRtClk, mtrRtClkOld=0, mtrLtSpdClk, mtrRtSpdClk, rbtDistClk, dirCmdClk;
int rbtDirClk;
int mrtLtRlPct=0;
int mtrRtRlPct=0;
int dirCmdPct;

// Dist, Dir, Spd, Continue=1/Stop=0
// Story: I smooth turn to the angle and drive to the distance. If commanded, I stop.
//    If commanded, I continue by incrementing the pointer when I get to the distance.
int path[][]={
		{12,0,40,1},
		{24,90,40,0}};
//		{0, 0, 50, 100}};

#define DIST_IDX 0
#define DIR_IDX 1
#define SPD_IDX 2
#define CONT_IDX 3
short PATH_IDX=0;

#define NEXT 0
#define CONTINUE 1
#define STOP 2
short sm_path=NEXT;

int dirCmdIntClk=0,dirCmdRatClk;
bool btn_z1=false,btn_z2=false,btn_z3=false,btn_z4=false;

#define WAIT 0
#define FOLLOW_PATH 1
#define DRIVE_JS 2
#define DRIVE_TOP_HAT 3
#define RETURN_PATH 4
#define NXT_CMD 5
short sm_cmd=NXT_CMD;

#define DEG2CLK 35
#define IN2CLK 300
#define DIR_KP 25 // Start tuning by setting this to around 25. Bigger numbers are a smaller gain
#define STOPDIST_CLK 12*IN2CLK
#define TURN_SPEED 15

#include "JoystickDriver.c"
#include "i_debug.c"
#include "i_rateLimit.c"
#include "i_limit.c"
#include "i_fallEdge.c"
#include "i_forwardDist2.c"

#define FOREGROUND_MS 50
task Foreground(){
  int timeLeft;
  int mtrCmdLtPct;
	int mtrCmdRtPct;

//	int iFrameCnt=0;
//	int out,in=0;

	while(true){
		ClearTimer(T1);
		hogCPU();
		//--------------------Foreground Loop Code---------------------------//

		int spdCmdPct=0; // Percent of full motor speed command


		// Calculate robot and motor information (speed, distance, direction)
		mrtLtClk = nMotorEncoder[ltWheelMotor];
		mtrRtClk = nMotorEncoder[rtWheelMotor];

		mtrLtSpdClk = mrtLtClk - mrtLtClkOld;mrtLtClkOld = mrtLtClk;
		mtrRtSpdClk = mtrRtClk - mtrRtClkOld;mtrRtClkOld = mtrRtClk;

		DebugInt(" sLt",mtrLtSpdClk);
		DebugInt(" sRt",mtrRtSpdClk);

		rbtDistClk = mtrRtClk + mrtLtClk;
		rbtDirClk = mrtLtClk - mtrRtClk;

		getJoystickSettings(joystick);     // update buttons and joysticks


		// ------------- The command state machine --------------------//
		DebugInt(" smp", sm_path);
		DebugInt(" smc", sm_cmd);
		switch (sm_cmd) {
		case NXT_CMD:

			if (FallEdge(joy1Btn(1),btn_z1)){
				dirCmdIntClk=0;
				nMotorEncoder[ltWheelMotor]=0;
				nMotorEncoder[rtWheelMotor]=0;
				sm_cmd=DRIVE_TOP_HAT;
			}
			if (FallEdge(joy1Btn(2),btn_z2)){
				sm_cmd=DRIVE_JS;
			}
			if (FallEdge(joy1Btn(3),btn_z3)){
				sm_cmd=RETURN_PATH;
			}
			if (FallEdge(joy1Btn(4),btn_z4)){
				sm_cmd=FOLLOW_PATH;
				PATH_IDX=0;
				nMotorEncoder[ltWheelMotor]=0;
				nMotorEncoder[rtWheelMotor]=0;
				sm_path=NEXT;
			}

			break;
		case FOLLOW_PATH:

			// ------------- The path state machine --------------------//
			switch (sm_path) {
			case NEXT:
	    		if (path[PATH_IDX][CONT_IDX]==CONTINUE) sm_path=CONTINUE;
	    		else sm_path=STOP;
				break;
			case CONTINUE:
				dirCmdClk=path[PATH_IDX][DIR_IDX]*DEG2CLK;
				spdCmdPct=path[PATH_IDX][SPD_IDX];

    		if (rbtDistClk>path[PATH_IDX][DIST_IDX]){
    			sm_path=NEXT;
    			PATH_IDX++;

    			// Protect the path index. It should never get to large.
					int s=sizeof(path)/sizeof(path[0])-1;
					DebugInt("siz",s);
					if (PATH_IDX>s) PATH_IDX=s;
    		}
				break;
			case STOP:
				dirCmdClk=path[PATH_IDX][DIR_IDX]*DEG2CLK;
				spdCmdPct=ForwardDist(path[PATH_IDX][DIST_IDX], rbtDistClk, path[PATH_IDX][SPD_IDX]);

				break;
			default:
					spdCmdPct=0;
			}

			// Calculate the direction command
//			DebugInt(" rbtDirC",rbtDirClk);
//			dirCmdIntClk=dirCmdIntClk+dirCmdRatClk;
			dirCmdPct = LimitSym((dirCmdClk-rbtDirClk)/DIR_KP, TURN_SPEED);

			// Calculate the motor commands
			mtrCmdLtPct=spdCmdPct+dirCmdPct;
			mtrCmdRtPct=spdCmdPct-dirCmdPct;

			// Limit the rate of change of the motor commands to prevent slipping.
			mtrCmdLtPct=RateLimit( mtrCmdLtPct, 6, mrtLtRlPct);
			mtrCmdRtPct=RateLimit( mtrCmdRtPct, 6, mtrRtRlPct );

			// Power the drive motors
			motor[ltWheelMotor]=mtrCmdLtPct;
			motor[rtWheelMotor]=mtrCmdRtPct;


			if (joy1Btn(1)||joy1Btn(2)||joy1Btn(3)||joy1Btn(4)) sm_cmd=NXT_CMD;
			break;
		case DRIVE_JS:

			motor[ltWheelMotor]=joystick.joy1_y2+joystick.joy1_x2;
			motor[rtWheelMotor]=joystick.joy1_y2-joystick.joy1_x2;

			if (joy1Btn(1)||joy1Btn(2)||joy1Btn(3)||joy1Btn(4)) sm_cmd=NXT_CMD;
			break;

		case DRIVE_TOP_HAT:
			spdCmdPct=0;
			dirCmdRatClk=0;
			if (joystick.joy1_TopHat == 0) { spdCmdPct = 40;dirCmdRatClk=0;}
			if (joystick.joy1_TopHat == 1) { spdCmdPct = 40;dirCmdRatClk=5;}
			if (joystick.joy1_TopHat == 2) { spdCmdPct = 0;dirCmdRatClk=10;}
			if (joystick.joy1_TopHat == 3) { spdCmdPct = -40;dirCmdRatClk=5;}
			if (joystick.joy1_TopHat == 4) { spdCmdPct = -40;dirCmdRatClk=0;}
			if (joystick.joy1_TopHat == 5) { spdCmdPct = -40;dirCmdRatClk=-5;}
			if (joystick.joy1_TopHat == 6) { spdCmdPct = 0;dirCmdRatClk=-10;}
			if (joystick.joy1_TopHat == 7) { spdCmdPct = 40;dirCmdRatClk=-5;}

			dirCmdIntClk=dirCmdIntClk+dirCmdRatClk;
			dirCmdPct = LimitSym((dirCmdClk-rbtDirClk)/DIR_KP, TURN_SPEED);

			// Calculate the motor commands
			mtrCmdLtPct=spdCmdPct+dirCmdPct;
			mtrCmdRtPct=spdCmdPct-dirCmdPct;

			// Limit the rate of change of the motor commands to prevent slipping.
			mtrCmdLtPct=RateLimit( mtrCmdLtPct, 6, mrtLtRlPct);
			mtrCmdRtPct=RateLimit( mtrCmdRtPct, 6, mtrRtRlPct );

			// Power the drive motors
			motor[ltWheelMotor]=mtrCmdLtPct;
			motor[rtWheelMotor]=mtrCmdRtPct;

			if (joy1Btn(1)||joy1Btn(2)||joy1Btn(3)||joy1Btn(4)) sm_cmd=NXT_CMD;
			break;
		case RETURN_PATH:
			if (joy1Btn(1)||joy1Btn(2)||joy1Btn(3)||joy1Btn(4)) sm_cmd=NXT_CMD;
			break;
		default:
		}


		//--------------------------End Foreground Code--------------------------//
		// Wait for next itteration
	  timeLeft=FOREGROUND_MS-time1[T1];
	  if (timeLeft<0) timeLeft=0;
	  DebugInt(" time", timeLeft);
	  releaseCPU();
	  wait1Msec(timeLeft);
	}// While
}//Foreground
task main()
{
	//--------------------INIT Code---------------------------//

		nMotorEncoder[ltWheelMotor]=0;
		nMotorEncoder[rtWheelMotor]=0;

	//--------------------------End INIT Code--------------------------//

  StartTask(Foreground, 255);

  while(true){

  	//-----------------Print the debug statements out------------------//
		DebugPrint();

	}// While
}// Main
//*/
