#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     rtMotor,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     ltMotor,       tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//
// As a SW programmer, I want the motors to travel at a constant speed to improve control on the field.
//
#include "i_Lowpass.c"

//#define Kp 3  // Kp
//#define Ki 2 // Ki
//#define Kd (-1)   //Kd
#define Kp 0.25  // Kp
#define Ki 0.05 // Ki
#define Kd (-0)   //Kd

int error=0;
int integral=0;
int acceleration=0;
//int distanceOld=0;
//int speed,speedOld=0;
int speed;
int output=0;
int mtrCnt,mtrCntOld=0;

bool failedPid=false;
int Pid(int speedCmd, int distance, int &distanceOld, int &speedOld, int &integral){
	int integralKi,errorKp;

	//AddToDatalog(0,distance);
//	distance = nMotorEncoder[motorB];  // find actual degrees of motor B
	speed = distance - distanceOld; distanceOld=distance;
	acceleration = speed - speedOld; speedOld=speed;
  error=speedCmd/Kp-speed;  // Normilize speedCmd to the size of motor command 0->100.
  errorKp=error*Kp;
  integral=integral+error;  // find value of integral
  #define MAX_INTEGRAL 30*Ki
	if (integral>MAX_INTEGRAL) integral=MAX_INTEGRAL; // Limit the value of the integral
  if (integral<-MAX_INTEGRAL) integral=-MAX_INTEGRAL;
  integralKi=integral*Ki;   // Normilize to the size of motor command 0->100.

//  output=errorKp+integralKi+Kd*acceleration;
  output=errorKp+integralKi;

  if (Lowpass(errorKp,0.2)>20 || failedPid){
  	failedPid=true;
  	output=0;
  }

  //AddToDatalog(1, actualDegreesC);

	return((int)output);
}

// Periodic Model used to read sensors and control the motors on a NXT brick
//
// As a software programmer, I want my tasks to run at a periodic rate. A periodic rate makes control, filtering,
//    and counting much easier.
//
#pragma DebuggerWindows ("debugStream")// Bring up the debug stream window

int count=0;
int timeLeft=0; // A global variable that sticks around each frame

// ------------------------Foreground Task -----------------------------//
// Run every second
#define FOREGROUND_MS 25
task main(){
	int spdCmd;
  //---------------------------INIT-----------------------------------//
	Pid_Init();

  //---------------------------END INIT-------------------------------//
//	while(SensorValue(endPgm) == 0){
	while(true){
		ClearTimer(T1);
		hogCPU(); //Prevent other tasks from running when this one is.
		//writeDebugStreamLine("Foreground\n"); //Let me know when the foreground runs
	  count=count+1; // Count the number of times the foreground runs.

	  //--------------------------FOREGROUND------------------------------------//
	  spdCmd=50;
	  int mtrCnt=nMotorEncoder[rtMotor];
	  int mtrCmd=Pid(spdCmd, mtrCnt, mtrCntOld, integral);
		motor[rtMotor]=motor[ltMotor]=mtrCmd;

	  //--------------------------END FOREGROUND--------------------------------//

	  timeLeft=FOREGROUND_MS-time1[T1]; // Calculate the time used in the foreground
	  releaseCPU(); // Let other tasks run now.
	  wait1Msec(timeLeft);// The time other tasks have to run before foreground takes control.

	  //------------Debug------------//
	 	if (count==1){
	  	writeDebugStreamLine("SpdCmd[%i],Kp[%i],Ki[%i],Kd[%i]",spdCmd,Kp,Ki,Kd);
	  	writeDebugStreamLine("TimeLeft,Error,MtrCmd,Speed,Integral,Distance");
	  }
	 	writeDebugStreamLine("%2i,%3i,%3i,%3i,%3i,%5i",timeLeft,error,mtrCmd,speed,integral,mtrCnt);

	}// While Loop
}// Foreground Main Task
